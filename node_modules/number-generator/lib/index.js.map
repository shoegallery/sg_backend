{"version":3,"file":"index.js.map","sources":["../src/utils.js","../src/fns/aleaRNGFactory.js","../src/fns/murmurhash2_x86_32.js","../src/fns/murmurhash3_x86_32.js","../src/fns/murmurhash3_x86_128.js","../src/fns/murmurhash3_x64_128.js"],"sourcesContent":["/**\n * Returns a multiple unsigned int32\n *\n * @private\n * @param {number} x Non linear base\n * @param {number} y Linear base\n * @return {number} Unsigned int32\n */\nexport function uMul32Getter(x, y) {\n  x = x | 0;\n  y = y | 0;\n  const nonLinear = x & 0xffff;\n  const linearBase = x >>> 16;\n\n  return (nonLinear * y + (((linearBase * y) & 0xffff) << 16)) | 0;\n}\n\n/**\n * Return an unsigned int32 from hash by position\n *\n * @private\n * @param {Uint8Array} bytes UTF8 string as array\n * @param {number} position String start position\n * @return {number} Unsigned int32\n */\nexport function uInt32Getter(bytes, position) {\n  return (\n    bytes[position++] +\n    (bytes[position++] << 8) +\n    (bytes[position++] << 16) +\n    (bytes[position++] << 24)\n  );\n}\n\n/**\n * Mix hash for x86\n *\n * @private\n * @param {number} hash Base number hash\n * @returns {number} Mixed number hash\n */\nexport function uInt32mix(hash) {\n  hash ^= hash >>> 16;\n  hash = uMul32Getter(hash, 0x85ebca6b);\n  hash ^= hash >>> 13;\n  hash = uMul32Getter(hash, 0xc2b2ae35);\n  hash ^= hash >>> 16;\n\n  return hash;\n}\n\n/**\n * Returns the int32 rotated left by the number of positions\n *\n * @private\n * @param {number} x Unsigned int32\n * @param {number} y Number representing bit positions\n * @returns {number}\n */\nexport function uInt32RotateLeft(x, y) {\n  return (x << y) | (x >>> (32 - y));\n}\n\n/**\n * Create concated and filled hash string\n *\n * @private\n * @param {number[]} hash Array containing hash parts as int, represented as tuple of 4\n * @returns {string} Concatenated and filled hash\n */\nexport function createConcatenatedHash([h1, h2, h3, h4]) {\n  const fill = \"00000000\";\n  return (\n    (fill + (h1 >>> 0).toString(16)).slice(-8) +\n    (fill + (h2 >>> 0).toString(16)).slice(-8) +\n    (fill + (h3 >>> 0).toString(16)).slice(-8) +\n    (fill + (h4 >>> 0).toString(16)).slice(-8)\n  );\n}\n\n/**\n * Throw an error if the given seed is invalid for a murmur hash algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidMurmurSeed(seed) {\n  if (seed !== undefined && seed % 1 !== 0) {\n    throw new TypeError(\"Expected seed to be an integer, float given\");\n  }\n}\n\n/**\n * Throw an error if the given seed is invalid for the alea algorithm\n *\n * @private\n * @param {number} seed A number value representing the seed\n */\nexport function throwInvalidAleaSeed(seed) {\n  if (seed % 1 !== 0 || seed <= 0) {\n    throw new TypeError(\n      `Expected seed to be an unsigned integer greater or equal 1, but got \"${seed}\"`\n    );\n  }\n}\n\n/**\n * Throw an error if a given hash is not a string\n *\n * @private\n * @param {string} hash The possible empty hash value\n * @param {string} functionName A function name to enhance the error message\n */\nexport function throwInvalidStringHash(hash, functionName) {\n  if (typeof hash !== \"string\") {\n    throw new TypeError(`${functionName}(): first argument is not a string.`);\n  }\n}\n\n/**\n * Encode non regular ASCII characters in string to array of chars\n *\n * @private\n * @param {string} str Encode a string into a Uint8 array\n * @returns {Uint8Array}\n */\nfunction encode(str) {\n  const length = str.length;\n  let resPos = -1;\n\n  // The Uint8Array's length must be at least 3x the length of the string because an invalid UTF-16\n  // takes up the equivalent space of 3 UTF-8 characters to encode it properly. However, Array's\n  // have an auto expanding length and 1.5x should be just the right balance for most uses.\n  const resultArray = new Uint8Array(length * 3);\n  let i = 0;\n\n  while (i !== length) {\n    let point = str.charCodeAt(i);\n    i += 1;\n\n    if (point >= 0xd800 && point <= 0xdbff) {\n      if (i === length) {\n        resultArray[(resPos += 1)] = 0xef; // 0b11101111\n        resultArray[(resPos += 1)] = 0xbf; // 0b10111111\n        resultArray[(resPos += 1)] = 0xbd; // 0b10111101\n        break;\n      }\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      const nextCode = str.charCodeAt(i);\n\n      if (nextCode >= 0xdc00 && nextCode <= 0xdfff) {\n        point = (point - 0xd800) * 0x400 + nextCode - 0xdc00 + 0x10000;\n        i += 1;\n\n        if (point > 0xffff) {\n          // point > 65535\n          resultArray[(resPos += 1)] = (0x1e /*0b11110*/ << 3) | (point >>> 18);\n          resultArray[(resPos += 1)] =\n            (0x2 /*0b10*/ << 6) | ((point >>> 12) & 0x3f); // 0b00111111\n          resultArray[(resPos += 1)] =\n            (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f); // 0b00111111\n          resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n          continue;\n        }\n      } else {\n        resultArray[(resPos += 1)] = 0xef; // 0b11101111\n        resultArray[(resPos += 1)] = 0xbf; // 0b10111111\n        resultArray[(resPos += 1)] = 0xbd; // 0b10111101\n        continue;\n      }\n    }\n\n    if (point <= 0x007f) {\n      resultArray[(resPos += 1)] = (0x0 /*0b0*/ << 7) | point;\n    } else if (point <= 0x07ff) {\n      resultArray[(resPos += 1)] = (0x6 /*0b110*/ << 5) | (point >>> 6);\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n    } else {\n      resultArray[(resPos += 1)] = (0xe /*0b1110*/ << 4) | (point >>> 12);\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | ((point >>> 6) & 0x3f); // 0b00111111\n      resultArray[(resPos += 1)] = (0x2 /*0b10*/ << 6) | (point & 0x3f); // 0b00111111\n    }\n  }\n\n  return resultArray.subarray(0, resPos + 1);\n}\n\n/**\n * Convert string to array of UTF 8 bytes\n *\n * @private\n * @param {string} str String to convert\n * @returns {Uint8Array} Encoded UTF8 chars\n */\nexport function toUtf8Bytes(str) {\n  const result = new Uint8Array(str.length);\n\n  for (let i = 0; i < str.length; i += 1) {\n    const charCode = str.charCodeAt(i);\n    if (charCode < 0 || charCode > 127) {\n      return encode(str);\n    }\n    result[i] = charCode;\n  }\n\n  return result;\n}\n","/** @module number-generator/lib/aleaRNGFactory */\nimport { throwInvalidAleaSeed } from \"../utils\";\n\n/**\n * Number generator with Alea algorithm.\n *\n * From {@link http://baagoe.com/en/RandomMusings/javascript/}\n * Johannes Baag√∏e <baagoe@baagoe.com>, 2010\n * Refactored and extended from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/aleaRNGFactory\n * @param {number} [initialSeed=1] Optional start seed number\n * @return {NumberGenerator} A number generator object\n */\nexport default (() => {\n  /**\n   * Number generator state\n   *\n   * @global\n   * @namespace NumberGeneratorState\n   * @property {number} correction Alea correction value\n   * @property {number[]} sequence An 3-length array of sequences for generating numbers\n   */\n\n  /**\n   * @global\n   * @namespace NumberGenerator\n   */\n\n  /**\n   * Set a seed for the generator\n   *\n   * @function setSeed\n   * @memberof NumberGenerator\n   * @param {number} seed The start seed to use for number generation\n   * @return {number} Returns the defined seed\n   */\n\n  /**\n   * Get an unsigned 32 bit float\n   *\n   * @function uFloat32\n   * @memberof NumberGenerator\n   * @return {number} Returns an unsigned 32 bit float\n   */\n\n  /**\n   * Get an unsigned 32 bit integer\n   *\n   * @function uInt32\n   * @memberof NumberGenerator\n   * @return {number} Returns an unsigned 32 bit integer\n   */\n\n  /**\n   * Returns the current number generator state\n   *\n   * @function getState\n   * @memberof NumberGenerator\n   * @return {NumberGeneratorState} Returns the internal number generator state\n   */\n\n  /**\n   * Set a new number generator state\n   *\n   * @function setState\n   * @memberof NumberGenerator\n   * @param {NumberGeneratorState} [state={correction: 1, sequence: [0, 0, 0]}] A pre configured state object\n   */\n\n  const CORRECTION_DEFAULT = 1;\n  const START_SEQUENCE_0 = 0;\n  const START_SEQUENCE_1 = 0;\n  const START_SEQUENCE_2 = 0;\n  const FRACTURE_FLOAT = 2 ** -32;\n  const FRACTURE_INT = 2 ** 32;\n  const TERM = 2091639;\n  const MULTIPLIER = 69069;\n\n  /**\n   * Number generator with Alea algorithm\n   *\n   * @param {number} [initialSeed=1] Optional start seed number\n   * @return {NumberGenerator} A number generator object\n   */\n  function aleaRNGFactory(initialSeed) {\n    let correction = CORRECTION_DEFAULT;\n    let sequence0 = START_SEQUENCE_0;\n    let sequence1 = START_SEQUENCE_1;\n    let sequence2 = START_SEQUENCE_2;\n\n    /**\n     * Set the used seed number\n     *\n     * @throws {TypeError} Throws an exception if seed is float or negative\n     * @param {number} seed A number value\n     * @return {number} The used number value\n     */\n    function setSeed(seed) {\n      throwInvalidAleaSeed(seed);\n\n      sequence0 = (seed >>> 0) * FRACTURE_FLOAT;\n      seed = (seed * MULTIPLIER + 1) >>> 0;\n      sequence1 = seed * FRACTURE_FLOAT;\n      seed = (seed * MULTIPLIER + 1) >>> 0;\n      sequence2 = seed * FRACTURE_FLOAT;\n      correction = CORRECTION_DEFAULT;\n\n      return seed;\n    }\n\n    /**\n     * Returns a generated random unsigned float number\n     *\n     * @return {number} Generated number\n     */\n    function uFloat32() {\n      const singleTerm = TERM * sequence0 + correction * FRACTURE_FLOAT;\n      correction = singleTerm | 0;\n      sequence0 = sequence1;\n      sequence1 = sequence2;\n      sequence2 = singleTerm - correction;\n      return sequence2;\n    }\n\n    /**\n     * Returns a generated random unsigned 32 integer\n     *\n     * @return {number} Generated number\n     */\n    function uInt32() {\n      return (uFloat32() * FRACTURE_INT) >>> 0;\n    }\n\n    /**\n     * Get the internal sequence state\n     *\n     * @return {NumberGeneratorState} An object defining the internal state\n     */\n    function getState() {\n      return {\n        correction,\n        sequence: [sequence0, sequence1, sequence2],\n      };\n    }\n\n    /**\n     * Set the internal sequence state\n     *\n     * @param {NumberGeneratorState} [state={correction: 1, sequence: [0, 0, 0]}] An object defining the internal state\n     */\n    function setState(state) {\n      const defaultState = {\n        correction: CORRECTION_DEFAULT,\n        sequence: [START_SEQUENCE_0, START_SEQUENCE_1, START_SEQUENCE_2],\n      };\n\n      state = state || defaultState;\n      state.sequence = state.sequence || [];\n\n      correction = state.correction || CORRECTION_DEFAULT;\n      sequence0 = state.sequence[0] || START_SEQUENCE_0;\n      sequence1 = state.sequence[1] || START_SEQUENCE_1;\n      sequence2 = state.sequence[2] || START_SEQUENCE_2;\n    }\n\n    setSeed(initialSeed === undefined ? 1 : initialSeed);\n\n    return { setSeed, uFloat32, uInt32, getState, setState };\n  }\n\n  return aleaRNGFactory;\n})();\n","/** @module number-generator/lib/murmurhash2_x86_32 */\nimport {\n  uMul32Getter,\n  uInt32Getter,\n  throwInvalidMurmurSeed,\n  throwInvalidStringHash,\n  toUtf8Bytes,\n} from \"../utils\";\n\n/**\n * Generate a non-cryptic 32 bit number hash for x86 with murmur2 algorithm.\n *\n * From {@link https://gist.github.com/raycmorgan/588423}\n * Ray Morgan, 2011\n * Refactored and extended including fixes for edge cases from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/murmurhash2_x86_32\n * @throws {TypeError} Throws an exception if hash is not a string\n * @throws {TypeError} Throws an exception if seed is a float\n * @param {string} str The base string hash to generate number\n * @param {number} [seed=0] An optional seed value\n * @return {number} Generated number\n */\nexport default (() => {\n  const MULTIPLIER = 0x5bd1e995;\n  const BASE = 24;\n\n  /**\n   * Return an unsigned int16 from hash by position\n   *\n   * @private\n   * @param {Uint8Array} hash String hash value\n   * @param {number} position String start position\n   * @return {number} Unsigned int16\n   */\n  const uInt16Getter = (hash, position) =>\n    hash[position++] + (hash[position] << 8);\n\n  /**\n   * Generate a non-cryptic 32 bit number hash for x86 with murmur2 algorithm.\n   *\n   * @throws {TypeError} Throws an exception if hash is not a string\n   * @throws {TypeError} Throws an exception if seed is a float\n   * @param {string} str The base string hash to generate number\n   * @param {number} [seed=0] An optional seed value\n   * @return {number} Generated number\n   */\n  function murmurhash2_x86_32(str, seed = 0) {\n    throwInvalidStringHash(str, \"murmurhash2_x86_32\");\n    throwInvalidMurmurSeed(seed);\n\n    const hash = toUtf8Bytes(str);\n    let currentIndex = 0;\n    let hashSum = seed ^ hash.length;\n    let length = hash.length;\n\n    while (length >= 4) {\n      let calculated = uInt32Getter(hash, currentIndex);\n\n      calculated = uMul32Getter(calculated, MULTIPLIER);\n      calculated ^= calculated >>> BASE;\n      calculated = uMul32Getter(calculated, MULTIPLIER);\n\n      hashSum = uMul32Getter(hashSum, MULTIPLIER);\n      hashSum ^= calculated;\n\n      currentIndex += 4;\n      length -= 4;\n    }\n\n    switch (length) {\n      case 3:\n        hashSum ^= uInt16Getter(hash, currentIndex);\n        hashSum ^= hash[currentIndex + 2] << 16;\n        hashSum = uMul32Getter(hashSum, MULTIPLIER);\n        break;\n      case 2:\n        hashSum ^= uInt16Getter(hash, currentIndex);\n        hashSum = uMul32Getter(hashSum, MULTIPLIER);\n        break;\n      case 1:\n        hashSum ^= hash[currentIndex];\n        hashSum = uMul32Getter(hashSum, MULTIPLIER);\n        break;\n    }\n\n    hashSum ^= hashSum >>> 13;\n    hashSum = uMul32Getter(hashSum, MULTIPLIER);\n    hashSum ^= hashSum >>> 15;\n\n    return hashSum >>> 0;\n  }\n\n  return murmurhash2_x86_32;\n})();\n","/** @module number-generator/lib/murmurhash3_x86_32 */\nimport {\n  uMul32Getter,\n  uInt32Getter,\n  uInt32mix,\n  uInt32RotateLeft,\n  toUtf8Bytes,\n  throwInvalidMurmurSeed,\n  throwInvalidStringHash,\n} from \"../utils\";\n\n/**\n * Generate a non-cryptic 32 bit number hash for x86 with murmur3 algorithm.\n *\n * From {@link https://github.com/karanlyons/murmurHash3.js}\n * Karan Lyons, 2014\n * Refactored and extended including fixes for edge cases from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/murmurhash3_x86_32\n * @throws {TypeError} Throws an exception if hash is not a string\n * @throws {TypeError} Throws an exception if seed is a float\n * @param {string} str The base string hash to generate number\n * @param {number} [seed=0] An optional seed value\n * @return {number} Generated number\n */\nexport default (() => {\n  const MULTIPLIER_1 = 0xcc9e2d51;\n  const MULTIPLIER_2 = 0x1b873593;\n\n  const CORRECTION = 0xe6546b64;\n\n  /**\n   * Generate a non-cryptic 32 bit number hash for x86 with murmur3 algorithm.\n   *\n   * @throws {TypeError} Throws an exception if hash is not a string\n   * @throws {TypeError} Throws an exception if seed is a float\n   * @param {string} str The base string hash to generate number\n   * @param {number} [seed=0] An optional seed value\n   * @return {number} Generated number\n   */\n  function murmurhash3_x86_32(str, seed = 0) {\n    throwInvalidStringHash(str, \"murmurhash3_x86_32\");\n    throwInvalidMurmurSeed(seed);\n\n    const hash = toUtf8Bytes(str);\n    const remainder = hash.length % 4;\n    const bytes = hash.length - remainder;\n\n    let calculated = 0;\n    let currentIndex = 0;\n    let hashSum = seed;\n\n    while (currentIndex < bytes) {\n      calculated = uInt32Getter(hash, currentIndex);\n\n      calculated = uMul32Getter(calculated, MULTIPLIER_1);\n      calculated = uInt32RotateLeft(calculated, 15);\n      calculated = uMul32Getter(calculated, MULTIPLIER_2);\n\n      hashSum ^= calculated;\n      hashSum = uInt32RotateLeft(hashSum, 13);\n      hashSum = uMul32Getter(hashSum, 5) + CORRECTION;\n\n      currentIndex += 4;\n    }\n\n    calculated = 0;\n\n    switch (remainder) {\n      case 3:\n        calculated ^= (hash[currentIndex + 2] & 0xff) << 16;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        calculated ^= (hash[currentIndex + 1] & 0xff) << 8;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        calculated ^= hash[currentIndex];\n        calculated = uMul32Getter(calculated, MULTIPLIER_1);\n        calculated = uInt32RotateLeft(calculated, 15);\n        calculated = uMul32Getter(calculated, MULTIPLIER_2);\n        hashSum ^= calculated;\n    }\n\n    hashSum ^= hash.length;\n    hashSum = uInt32mix(hashSum);\n\n    return hashSum >>> 0;\n  }\n\n  return murmurhash3_x86_32;\n})();\n","/** @module number-generator/lib/murmurhash3_x86_128 */\nimport {\n  throwInvalidMurmurSeed,\n  throwInvalidStringHash,\n  uInt32mix,\n  uInt32RotateLeft,\n  uMul32Getter,\n  toUtf8Bytes,\n  createConcatenatedHash,\n} from \"../utils\";\n\n/**\n * Generate a non-cryptic 128 bit number hash for x86 with murmur3 algorithm.\n *\n * From {@link https://github.com/karanlyons/murmurHash3.js}\n * Karan Lyons, 2014\n * Refactored and extended including fixes for edge cases from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/murmurhash3_x86_128\n * @throws {TypeError} Throws an exception if hash is not a string\n * @throws {TypeError} Throws an exception if seed is a float\n * @param {string} str The base string hash to generate number\n * @param {number} [seed=0] An optional seed value\n * @return {string} Generated 128 bit hash\n */\nexport default (() => {\n  const MULTIPLIER_1 = 0x239b961b;\n  const MULTIPLIER_2 = 0xab0e9789;\n  const MULTIPLIER_3 = 0x38b34ae5;\n  const MULTIPLIER_4 = 0xa1e38b93;\n\n  const CORRECTION_1 = 0x561ccd1b;\n  const CORRECTION_2 = 0x0bcaa747;\n  const CORRECTION_3 = 0x96cd1c35;\n  const CORRECTION_4 = 0x32ac3b17;\n\n  /**\n   * Generate a non-cryptic 128 bit number hash for x86 with murmur3 algorithm.\n   *\n   * @throws {TypeError} Throws an exception if hash is not a string\n   * @throws {TypeError} Throws an exception if seed is a float\n   * @param {string} str The base string hash to generate number\n   * @param {number} [seed=0] An optional seed value\n   * @return {string} Generated 128 bit hash\n   */\n  function murmurhash3_x86_128(str, seed = 0) {\n    throwInvalidStringHash(str, \"murmurhash3_x86_128\");\n    throwInvalidMurmurSeed(seed);\n\n    const hash = toUtf8Bytes(str);\n    const remainder = hash.length % 16;\n    const bytes = hash.length - remainder;\n\n    let hashSum1 = seed;\n    let hashSum2 = seed;\n    let hashSum3 = seed;\n    let hashSum4 = seed;\n\n    let calculated1 = 0;\n    let calculated2 = 0;\n    let calculated3 = 0;\n    let calculated4 = 0;\n\n    let currentIndex = 0;\n\n    while (currentIndex < bytes) {\n      calculated1 =\n        (hash[currentIndex] & 0xff) |\n        ((hash[currentIndex + 1] & 0xff) << 8) |\n        ((hash[currentIndex + 2] & 0xff) << 16) |\n        ((hash[currentIndex + 3] & 0xff) << 24);\n      calculated2 =\n        (hash[currentIndex + 4] & 0xff) |\n        ((hash[currentIndex + 5] & 0xff) << 8) |\n        ((hash[currentIndex + 6] & 0xff) << 16) |\n        ((hash[currentIndex + 7] & 0xff) << 24);\n      calculated3 =\n        (hash[currentIndex + 8] & 0xff) |\n        ((hash[currentIndex + 9] & 0xff) << 8) |\n        ((hash[currentIndex + 10] & 0xff) << 16) |\n        ((hash[currentIndex + 11] & 0xff) << 24);\n      calculated4 =\n        (hash[currentIndex + 12] & 0xff) |\n        ((hash[currentIndex + 13] & 0xff) << 8) |\n        ((hash[currentIndex + 14] & 0xff) << 16) |\n        ((hash[currentIndex + 15] & 0xff) << 24);\n\n      calculated1 = uMul32Getter(calculated1, MULTIPLIER_1);\n      calculated1 = uInt32RotateLeft(calculated1, 15);\n      calculated1 = uMul32Getter(calculated1, MULTIPLIER_2);\n      hashSum1 ^= calculated1;\n\n      hashSum1 = uInt32RotateLeft(hashSum1, 19);\n      hashSum1 += hashSum2;\n      hashSum1 = uMul32Getter(hashSum1, 5) + CORRECTION_1;\n\n      calculated2 = uMul32Getter(calculated2, MULTIPLIER_2);\n      calculated2 = uInt32RotateLeft(calculated2, 16);\n      calculated2 = uMul32Getter(calculated2, MULTIPLIER_3);\n      hashSum2 ^= calculated2;\n\n      hashSum2 = uInt32RotateLeft(hashSum2, 17);\n      hashSum2 += hashSum3;\n      hashSum2 = uMul32Getter(hashSum2, 5) + CORRECTION_2;\n\n      calculated3 = uMul32Getter(calculated3, MULTIPLIER_3);\n      calculated3 = uInt32RotateLeft(calculated3, 17);\n      calculated3 = uMul32Getter(calculated3, MULTIPLIER_4);\n      hashSum3 ^= calculated3;\n\n      hashSum3 = uInt32RotateLeft(hashSum3, 15);\n      hashSum3 += hashSum4;\n      hashSum3 = uMul32Getter(hashSum3, 5) + CORRECTION_3;\n\n      calculated4 = uMul32Getter(calculated4, MULTIPLIER_4);\n      calculated4 = uInt32RotateLeft(calculated4, 18);\n      calculated4 = uMul32Getter(calculated4, MULTIPLIER_1);\n      hashSum4 ^= calculated4;\n\n      hashSum4 = uInt32RotateLeft(hashSum4, 13);\n      hashSum4 += hashSum1;\n      hashSum4 = uMul32Getter(hashSum4, 5) + CORRECTION_4;\n\n      currentIndex += 16;\n    }\n\n    calculated1 = 0;\n    calculated2 = 0;\n    calculated3 = 0;\n    calculated4 = 0;\n\n    switch (remainder) {\n      case 15:\n        calculated4 ^= hash[currentIndex + 14] << 16;\n      // eslint-disable-next-line no-fallthrough\n      case 14:\n        calculated4 ^= hash[currentIndex + 13] << 8;\n      // eslint-disable-next-line no-fallthrough\n      case 13:\n        calculated4 ^= hash[currentIndex + 12];\n        calculated4 = uMul32Getter(calculated4, MULTIPLIER_4);\n        calculated4 = uInt32RotateLeft(calculated4, 18);\n        calculated4 = uMul32Getter(calculated4, MULTIPLIER_1);\n        hashSum4 ^= calculated4;\n      // eslint-disable-next-line no-fallthrough\n      case 12:\n        calculated3 ^= hash[currentIndex + 11] << 24;\n      // eslint-disable-next-line no-fallthrough\n      case 11:\n        calculated3 ^= hash[currentIndex + 10] << 16;\n      // eslint-disable-next-line no-fallthrough\n      case 10:\n        calculated3 ^= hash[currentIndex + 9] << 8;\n      // eslint-disable-next-line no-fallthrough\n      case 9:\n        calculated3 ^= hash[currentIndex + 8];\n        calculated3 = uMul32Getter(calculated3, MULTIPLIER_3);\n        calculated3 = uInt32RotateLeft(calculated3, 17);\n        calculated3 = uMul32Getter(calculated3, MULTIPLIER_4);\n        hashSum3 ^= calculated3;\n      // eslint-disable-next-line no-fallthrough\n      case 8:\n        calculated2 ^= hash[currentIndex + 7] << 24;\n      // eslint-disable-next-line no-fallthrough\n      case 7:\n        calculated2 ^= hash[currentIndex + 6] << 16;\n      // eslint-disable-next-line no-fallthrough\n      case 6:\n        calculated2 ^= hash[currentIndex + 5] << 8;\n      // eslint-disable-next-line no-fallthrough\n      case 5:\n        calculated2 ^= hash[currentIndex + 4];\n        calculated2 = uMul32Getter(calculated2, MULTIPLIER_2);\n        calculated2 = uInt32RotateLeft(calculated2, 16);\n        calculated2 = uMul32Getter(calculated2, MULTIPLIER_3);\n        hashSum2 ^= calculated2;\n      // eslint-disable-next-line no-fallthrough\n      case 4:\n        calculated1 ^= hash[currentIndex + 3] << 24;\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        calculated1 ^= hash[currentIndex + 2] << 16;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        calculated1 ^= hash[currentIndex + 1] << 8;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        calculated1 ^= hash[currentIndex];\n        calculated1 = uMul32Getter(calculated1, MULTIPLIER_1);\n        calculated1 = uInt32RotateLeft(calculated1, 15);\n        calculated1 = uMul32Getter(calculated1, MULTIPLIER_2);\n        hashSum1 ^= calculated1;\n    }\n\n    hashSum1 ^= hash.length;\n    hashSum2 ^= hash.length;\n    hashSum3 ^= hash.length;\n    hashSum4 ^= hash.length;\n\n    hashSum1 += hashSum2;\n    hashSum1 += hashSum3;\n    hashSum1 += hashSum4;\n    hashSum2 += hashSum1;\n    hashSum3 += hashSum1;\n    hashSum4 += hashSum1;\n\n    hashSum1 = uInt32mix(hashSum1);\n    hashSum2 = uInt32mix(hashSum2);\n    hashSum3 = uInt32mix(hashSum3);\n    hashSum4 = uInt32mix(hashSum4);\n\n    hashSum1 += hashSum2;\n    hashSum1 += hashSum3;\n    hashSum1 += hashSum4;\n    hashSum2 += hashSum1;\n    hashSum3 += hashSum1;\n    hashSum4 += hashSum1;\n\n    return createConcatenatedHash([hashSum1, hashSum2, hashSum3, hashSum4]);\n  }\n\n  return murmurhash3_x86_128;\n})();\n","/** @module number-generator/lib/murmurhash3_x64_128 */\nimport {\n  createConcatenatedHash,\n  throwInvalidMurmurSeed,\n  throwInvalidStringHash,\n  toUtf8Bytes,\n} from \"../utils\";\n\n/**\n * Generate a non-cryptic 128 bit number hash for x64 with murmur3 algorithm.\n *\n * From {@link https://github.com/karanlyons/murmurHash3.js}\n * Karan Lyons, 2014\n * Refactored and extended including fixes for edge cases from Martin Helmut Fieber <info@martin-fieber.de>\n *\n * @export number-generator/lib/murmurhash3_x86_128\n * @throws {TypeError} Throws an exception if hash is not a string\n * @throws {TypeError} Throws an exception if seed is a float\n * @param {string} str The base string hash to generate number\n * @param {number} [seed=0] An optional seed value\n * @return {string} Generated 128 bit hash\n */\nexport default (() => {\n  const MULTIPLIER_1 = [0x87c37b91, 0x114253d5];\n  const MULTIPLIER_2 = [0x4cf5ad43, 0x2745937f];\n\n  const BIT_AND_BASE = 0xffff;\n\n  /**\n   * Multiple two 64 bit int (as an array with two 32 bit int)\n   *\n   * @private\n   * @param {number[]} x 64 bit int as two 32 bit int, represented as tuple of 2\n   * @param {number[]} y 64 bit int as two 32 bit int, represented as tuple of 2\n   * @returns {number[]} Multiplied 64 bit int as two 32 bit int, represented as tuple of 2\n   */\n  function uInt64Multiply(x, y) {\n    const o = [0, 0, 0, 0];\n\n    x = [x[0] >>> 16, x[0] & BIT_AND_BASE, x[1] >>> 16, x[1] & BIT_AND_BASE];\n    y = [y[0] >>> 16, y[0] & BIT_AND_BASE, y[1] >>> 16, y[1] & BIT_AND_BASE];\n\n    o[3] += x[3] * y[3];\n    o[2] += o[3] >>> 16;\n    o[3] &= BIT_AND_BASE;\n\n    o[2] += x[2] * y[3];\n    o[1] += o[2] >>> 16;\n    o[2] &= BIT_AND_BASE;\n\n    o[2] += x[3] * y[2];\n    o[1] += o[2] >>> 16;\n    o[2] &= BIT_AND_BASE;\n\n    o[1] += x[1] * y[3];\n    o[0] += o[1] >>> 16;\n    o[1] &= BIT_AND_BASE;\n\n    o[1] += x[2] * y[2];\n    o[0] += o[1] >>> 16;\n    o[1] &= BIT_AND_BASE;\n\n    o[1] += x[3] * y[1];\n    o[0] += o[1] >>> 16;\n    o[1] &= BIT_AND_BASE;\n\n    o[0] += x[0] * y[3] + x[1] * y[2] + x[2] * y[1] + x[3] * y[0];\n    o[0] &= BIT_AND_BASE;\n\n    return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n  }\n\n  /**\n   * Add two 64 bit int together (as an array with two 32 bit int)\n   *\n   * @private\n   * @param {number[]} x 64 bit int as two 32 bit int, represented as tuple of 2\n   * @param {number[]} y 64 bit int as two 32 bit int, represented as tuple of 2\n   * @returns {number[]} Added 64 bit int as two 32 bit int, represented as tuple of 2\n   */\n  function uInt64Add(x, y) {\n    const o = [0, 0, 0, 0];\n\n    x = [x[0] >>> 16, x[0] & BIT_AND_BASE, x[1] >>> 16, x[1] & BIT_AND_BASE];\n    y = [y[0] >>> 16, y[0] & BIT_AND_BASE, y[1] >>> 16, y[1] & BIT_AND_BASE];\n\n    o[3] += x[3] + y[3];\n    o[2] += o[3] >>> 16;\n    o[3] &= BIT_AND_BASE;\n\n    o[2] += x[2] + y[2];\n    o[1] += o[2] >>> 16;\n    o[2] &= BIT_AND_BASE;\n\n    o[1] += x[1] + y[1];\n    o[0] += o[1] >>> 16;\n    o[1] &= BIT_AND_BASE;\n\n    o[0] += x[0] + y[0];\n    o[0] &= BIT_AND_BASE;\n\n    return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n  }\n\n  /**\n   * Returns the 64 int rotated left by the number of positions\n   *\n   * @private\n   * @param {number[]} bytes 64 bit int as two 32 bit int, represented as tuple of 2\n   * @param {number} position Positions to rotate int\n   * @returns {number[]} Left rotated 64 bit int as two 32 bit int, represented as tuple of 2\n   */\n  function uInt64RotateLeft(bytes, position) {\n    position %= 64;\n\n    if (position < 32) {\n      return [\n        (bytes[0] << position) | (bytes[1] >>> (32 - position)),\n        (bytes[1] << position) | (bytes[0] >>> (32 - position)),\n      ];\n    }\n\n    position -= 32;\n    return [\n      (bytes[1] << position) | (bytes[0] >>> (32 - position)),\n      (bytes[0] << position) | (bytes[1] >>> (32 - position)),\n    ];\n  }\n\n  /**\n   * Returns the 64 int with left shift by the number of positions\n   *\n   * @private\n   * @param {number[]} bytes 64 bit int as two 32 bit int, represented as tuple of 2\n   * @param {number} position Positions to shift int\n   * @returns {number[]} Multiplied 64 bit int as two 32 bit int, represented as tuple of 2\n   */\n  function uInt64LeftShift(bytes, position) {\n    position %= 64;\n\n    if (position < 32) {\n      return [\n        (bytes[0] << position) | (bytes[1] >>> (32 - position)),\n        bytes[1] << position,\n      ];\n    }\n\n    return [bytes[1] << (position - 32), 0];\n  }\n\n  /**\n   * Returns the 64 int xor-ed together from two 64 int\n   *\n   * @private\n   * @param {number[]} x 64 bit int as two 32 bit int, represented as tuple of 2\n   * @param {number[]} y 64 bit int as two 32 bit int, represented as tuple of 2\n   * @returns {number[]} Xor-ed 64 bit int, represented as tuple of 2\n   */\n  function uInt64Xor(x, y) {\n    return [x[0] ^ y[0], x[1] ^ y[1]];\n  }\n\n  /**\n   * Mix hash for x64\n   *\n   * @private\n   * @param {number[]} hash 64 bit int as two 32 bit int, represented as tuple of 2\n   * @returns {number[]} Mixed 64 bit int as two 32 bit int, represented as tuple of 2\n   */\n  function uInt64mix(hash) {\n    hash = uInt64Xor(hash, [0, hash[0] >>> 1]);\n    hash = uInt64Multiply(hash, [0xff51afd7, 0xed558ccd]);\n    hash = uInt64Xor(hash, [0, hash[0] >>> 1]);\n    hash = uInt64Multiply(hash, [0xc4ceb9fe, 0x1a85ec53]);\n    hash = uInt64Xor(hash, [0, hash[0] >>> 1]);\n\n    return hash;\n  }\n\n  /**\n   * Generate a non-cryptic 128 bit number hash for x64 with murmur3 algorithm.\n   *\n   * @throws {TypeError} Throws an exception if hash is not a string\n   * @throws {TypeError} Throws an exception if seed is a float\n   * @param {string} str The base string hash to generate number\n   * @param {number} [seed=0] An optional seed value\n   * @return {string} Generated 128 bit hash\n   */\n  function murmurhash3_x64_128(str, seed = 0) {\n    throwInvalidStringHash(str, \"murmurhash3_x64_128\");\n    throwInvalidMurmurSeed(seed);\n\n    const hash = toUtf8Bytes(str);\n    const remainder = hash.length % 16;\n    const bytes = hash.length - remainder;\n\n    let hashSum1 = [0, seed];\n    let hashSum2 = [0, seed];\n\n    let calculated1 = [0, 0];\n    let calculated2 = [0, 0];\n\n    let currentIndex = 0;\n\n    while (currentIndex < bytes) {\n      calculated1 = [\n        (hash[currentIndex + 4] & 0xff) |\n          ((hash[currentIndex + 5] & 0xff) << 8) |\n          ((hash[currentIndex + 6] & 0xff) << 16) |\n          ((hash[currentIndex + 7] & 0xff) << 24),\n        (hash[currentIndex] & 0xff) |\n          ((hash[currentIndex + 1] & 0xff) << 8) |\n          ((hash[currentIndex + 2] & 0xff) << 16) |\n          ((hash[currentIndex + 3] & 0xff) << 24),\n      ];\n      calculated2 = [\n        (hash[currentIndex + 12] & 0xff) |\n          ((hash[currentIndex + 13] & 0xff) << 8) |\n          ((hash[currentIndex + 14] & 0xff) << 16) |\n          ((hash[currentIndex + 15] & 0xff) << 24),\n        (hash[currentIndex + 8] & 0xff) |\n          ((hash[currentIndex + 9] & 0xff) << 8) |\n          ((hash[currentIndex + 10] & 0xff) << 16) |\n          ((hash[currentIndex + 11] & 0xff) << 24),\n      ];\n\n      calculated1 = uInt64Multiply(calculated1, MULTIPLIER_1);\n      calculated1 = uInt64RotateLeft(calculated1, 31);\n      calculated1 = uInt64Multiply(calculated1, MULTIPLIER_2);\n      hashSum1 = uInt64Xor(hashSum1, calculated1);\n\n      hashSum1 = uInt64RotateLeft(hashSum1, 27);\n      hashSum1 = uInt64Add(hashSum1, hashSum2);\n      hashSum1 = uInt64Add(uInt64Multiply(hashSum1, [0, 5]), [0, 0x52dce729]);\n\n      calculated2 = uInt64Multiply(calculated2, MULTIPLIER_2);\n      calculated2 = uInt64RotateLeft(calculated2, 33);\n      calculated2 = uInt64Multiply(calculated2, MULTIPLIER_1);\n      hashSum2 = uInt64Xor(hashSum2, calculated2);\n\n      hashSum2 = uInt64RotateLeft(hashSum2, 31);\n      hashSum2 = uInt64Add(hashSum2, hashSum1);\n      hashSum2 = uInt64Add(uInt64Multiply(hashSum2, [0, 5]), [0, 0x38495ab5]);\n\n      currentIndex += 16;\n    }\n\n    calculated1 = [0, 0];\n    calculated2 = [0, 0];\n\n    switch (remainder) {\n      case 15:\n        calculated2 = uInt64Xor(\n          calculated2,\n          uInt64LeftShift([0, hash[currentIndex + 14]], 48)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 14:\n        calculated2 = uInt64Xor(\n          calculated2,\n          uInt64LeftShift([0, hash[currentIndex + 13]], 40)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 13:\n        calculated2 = uInt64Xor(\n          calculated2,\n          uInt64LeftShift([0, hash[currentIndex + 12]], 32)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 12:\n        calculated2 = uInt64Xor(\n          calculated2,\n          uInt64LeftShift([0, hash[currentIndex + 11]], 24)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 11:\n        calculated2 = uInt64Xor(\n          calculated2,\n          uInt64LeftShift([0, hash[currentIndex + 10]], 16)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 10:\n        calculated2 = uInt64Xor(\n          calculated2,\n          uInt64LeftShift([0, hash[currentIndex + 9]], 8)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 9:\n        calculated2 = uInt64Xor(calculated2, [0, hash[currentIndex + 8]]);\n        calculated2 = uInt64Multiply(calculated2, MULTIPLIER_2);\n        calculated2 = uInt64RotateLeft(calculated2, 33);\n        calculated2 = uInt64Multiply(calculated2, MULTIPLIER_1);\n        hashSum2 = uInt64Xor(hashSum2, calculated2);\n      // eslint-disable-next-line no-fallthrough\n      case 8:\n        calculated1 = uInt64Xor(\n          calculated1,\n          uInt64LeftShift([0, hash[currentIndex + 7]], 56)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 7:\n        calculated1 = uInt64Xor(\n          calculated1,\n          uInt64LeftShift([0, hash[currentIndex + 6]], 48)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 6:\n        calculated1 = uInt64Xor(\n          calculated1,\n          uInt64LeftShift([0, hash[currentIndex + 5]], 40)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 5:\n        calculated1 = uInt64Xor(\n          calculated1,\n          uInt64LeftShift([0, hash[currentIndex + 4]], 32)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 4:\n        calculated1 = uInt64Xor(\n          calculated1,\n          uInt64LeftShift([0, hash[currentIndex + 3]], 24)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        calculated1 = uInt64Xor(\n          calculated1,\n          uInt64LeftShift([0, hash[currentIndex + 2]], 16)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        calculated1 = uInt64Xor(\n          calculated1,\n          uInt64LeftShift([0, hash[currentIndex + 1]], 8)\n        );\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        calculated1 = uInt64Xor(calculated1, [0, hash[currentIndex]]);\n        calculated1 = uInt64Multiply(calculated1, MULTIPLIER_1);\n        calculated1 = uInt64RotateLeft(calculated1, 31);\n        calculated1 = uInt64Multiply(calculated1, MULTIPLIER_2);\n        hashSum1 = uInt64Xor(hashSum1, calculated1);\n    }\n\n    hashSum1 = uInt64Xor(hashSum1, [0, hash.length]);\n    hashSum2 = uInt64Xor(hashSum2, [0, hash.length]);\n\n    hashSum1 = uInt64Add(hashSum1, hashSum2);\n    hashSum2 = uInt64Add(hashSum2, hashSum1);\n\n    hashSum1 = uInt64mix(hashSum1);\n    hashSum2 = uInt64mix(hashSum2);\n\n    hashSum1 = uInt64Add(hashSum1, hashSum2);\n    hashSum2 = uInt64Add(hashSum2, hashSum1);\n\n    return createConcatenatedHash([\n      hashSum1[0],\n      hashSum1[1],\n      hashSum2[0],\n      hashSum2[1],\n    ]);\n  }\n\n  return murmurhash3_x64_128;\n})();\n"],"names":["uMul32Getter","x","y","uInt32Getter","bytes","position","uInt32mix","hash","uInt32RotateLeft","createConcatenatedHash","h1","h2","h3","h4","fill","toString","slice","throwInvalidMurmurSeed","seed","undefined","TypeError","throwInvalidStringHash","functionName","encode","str","length","resPos","resultArray","Uint8Array","i","point","charCodeAt","nextCode","subarray","toUtf8Bytes","result","charCode","FRACTURE_FLOAT","FRACTURE_INT","MULTIPLIER","uInt16Getter","MULTIPLIER_1","MULTIPLIER_2","CORRECTION","initialSeed","correction","sequence0","sequence1","sequence2","setSeed","throwInvalidAleaSeed","uFloat32","singleTerm","uInt32","getState","sequence","setState","state","currentIndex","hashSum","calculated","remainder","MULTIPLIER_3","MULTIPLIER_4","CORRECTION_1","CORRECTION_2","CORRECTION_3","CORRECTION_4","hashSum1","hashSum2","hashSum3","hashSum4","calculated1","calculated2","calculated3","calculated4","BIT_AND_BASE","uInt64Multiply","o","uInt64Add","uInt64RotateLeft","uInt64LeftShift","uInt64Xor","uInt64mix"],"mappings":"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"}